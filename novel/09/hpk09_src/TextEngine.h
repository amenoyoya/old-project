//-----------------------------------------------------------------------------------------
//	TexitEngine.h
//-----------------------------------------------------------------------------------------


#define	SIZE_OF_TEXT_BUF 0xffff		//テキストバッファのサイズ

extern unsigned char	TEXT_BUF[SIZE_OF_TEXT_BUF];	//スクリプトを読み込むエリア

extern unsigned char	*TEXT;	//Text pointer（テキスト解釈位置をポイントします）

#define DEFAULT_FONT_SIZE  20		// default=26
#define	DEFAULT_TEXT_X_TOP 20		//テキスト表示エリア左肩(Ｘ)
#define DEFAULT_TEXT_Y_TOP 20		//テキスト表示エリア左肩(Ｙ)
#define DEFAULT_TEXT_X_END (640-20)	//テキスト表示エリア右下(Ｘ) [CR]ｽﾌﾟﾗｲﾄ分余計に右側を開ける
#define DEFAULT_TEXT_Y_END (480-20)	//テキスト表示エリア右下(Ｙ)

#define	DEFAULT_TEXT_WAIT  30	//１文字表示のウェイト(ms)

//記述を簡略化するためのおまじない♪
#define	TEXT_X_TOP		(Mode_stat._TEXT_X_TOP) 
#define	TEXT_Y_TOP		(Mode_stat._TEXT_Y_TOP)
#define	TEXT_X_END		(Mode_stat._TEXT_X_END)
#define	TEXT_Y_END		(Mode_stat._TEXT_Y_END)

#define	TEXT_X			(Mode_stat._TEXT_X)
#define	TEXT_Y			(Mode_stat._TEXT_Y)
#define	TEXT_X_OLD		(Mode_stat._TEXT_X_OLD)
#define TEXT_Y_OLD		(Mode_stat._TEXT_Y_OLD)
#define	Font_Size		(Mode_stat._Font_Size)
#define	TEXT_X_PITCH	(Mode_stat._TEXT_X_PITCH)
#define	TEXT_Y_PITCH	(Mode_stat._TEXT_Y_PITCH)

#define	TEXT_WAIT		(Mode_stat._TEXT_WAIT)

//static	DWORD TEXT_TIMER;	//タイマー

//	Mode_stat._TEXT_X_END = x2 - Mode_stat._TEXT_X_PITCH*2; 
//	Mode_stat._TEXT_Y_END = y2 - Mode_stat._TEXT_Y_PITCH*2;

//---------------------------------------------------------------
//	プロトタイプ（必要最小限しかありません：^^;）
//---------------------------------------------------------------

extern void _Memory_text_page_top();


//-------------------------------------
//	TEXTエンジン初期化
//-------------------------------------

void _Set_Default_params();
	//デフォルトパラメータの設定

void _Calc_TextEngine_params();
	//フォントサイズ等の変更を行った際に、他の定数の整合性をとる関数。
	//_Set_Default_params() のサブセット＋α・・・かな？


void _Init_text_pos_XY();
	//テキスト表示位置の初期化


void Init_Text_engine();
	//イニシャライズ操作の「親」関数


//-------------------------------------
//	文字位置のインクリメント
//-------------------------------------

void Incriment_textp_pos(int inc);	
	//文字表示位置のインクリメント
	//	int inc：何byteインクリメントするか→１or2

//-------------------------------------
//	１０進数テキストの解析
//-------------------------------------

int kaiseki_10();
	// 10進数テキストの解析

//-------------------------------------------
//	テキスト文字列の解析（スペース区切り版）
//-------------------------------------------

char *Kaiseki_TextStr();
	//	テキストから文字列を切出す


//-------------------------------------------
//	テキスト文字列の解析（[CR]区切り版）
//-------------------------------------------

char *Kaiseki_TextStr_CR();
	//	テキストから文字列を切出す
	//	Kaiseki_TextStr()との違いは、[CR][LF]のみを区切りとして扱うところ。



//-------------------------------------------
//	改ページ/画面切替時のページ先頭位置メモ
//-------------------------------------------

void _Memory_text_page_top();
	//改ページ直後のテキストポインタを、SAVE用に記憶しておく
	//（SAVE/LOAD時に「そのページの先頭から」を基準にしたいから ^^;）


//##############################################################################
//	スクリプト実行部の親関数
//##############################################################################

int Text_command_manager();
	//	テキストファイルで # を見つけたところでこの関数を呼び出す。	
	//	ポインタ TEXT は、次のコマンドを指し示すよう、インクリメント
	//	されて返る。										


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


//-----------------------------------------------------------------------------
//	特定文字列の表示
//
//	「\」で始まる特殊文字列を展開する関数群です。基本動作は、必要な
//	文字列をグローバルなバッファ STR_BUF に展開し、テキストポインタ
//	TEXT を強制的にバッファに飛ばして表示を行うというものです。
//	バッファには文字列終端を示す \EOS (End Of String)というコマンドを
//	埋め込んでおき、これを検出したところで TEXT を元のスクリプト上に
//	戻してやります。
//
//	※インタプリタは、一時的にバッファへ飛ばされていることは知らずに
//	  せっせとテキスト表示を続けている訳です〜〜♪（^0^）。（一種の
//	「化かし」ですね♪）
//-----------------------------------------------------------------------------

//unsigned char	STR_BUF[512];	//文字列展開用バッファ
//unsigned char	*OLD_TEXT;		//テキストポインタ *TEXT の保存用

//----------------------------------------------------------
//	終端処理
//
//	書式：\EOS
//
//	テキストポインタ TEXT を OLD_TEXT の内容に戻します。
//
//	注：このコマンドは内部処理用です。通常のコマンドスクリ
//	    プト上では絶対に使用してはいけません（^^;）。
//----------------------------------------------------------

int	Str_EOS();

//----------------------------------------------------------
//	フラグの数値を全角文字に変換して表示する
//
//	書式：\flag n
//	
//	フラグを変数代わりに使うときに用います。「キミがここに
//	来たのは××回目だね」な〜んて表示をしたいときに便利♪
//
//----------------------------------------------------------

int Str_flag_val();
	//	フラグの数値を全角文字列にして表示する


//###############################################################################
//	文字列指定子マネージャー
//###############################################################################

int Text_string_manager();
	//	テキストファイルで \ を見つけたところでこの関数を呼び出す。
	//	「\」に続く文字列はシステム内で使われる変数やフラグ名で、
	//	ゲームの進行に従って変化する（つまり作者がスクリプトを書いて
	//	いる段階では内容が確定していない）要素を記述するためのものです。					
	//																
	//	戻り値：とりあえず 0 を返します																		

//#################################################################
//	１byte系のコントロール文字の解析
//	※コマンド文字列を発見した場合、ここからスクリプト実行部を呼び出す
//#################################################################

int Check_text_control();	//コントロール文字の解析
	//コントロール文字であればその処理をして true を返し、
	//コントロール文字でなければ何もしないで false を返す。


//###############################################################
//	TEXTエンジン（シナリオ･インタプリタ）本体部
//###############################################################

//-------------------------------------
//	１文字単位の表示（合成→バック面）
//-------------------------------------
void _ADV_disp_text( int x, int y, int width, int height ,int flag );
	//グラフィック画面とテキスト画面を合成しながらバックサーフェイスに展開する。
	//		flag: 0=背景で文字を消去  1=１byte文字  2=２byte文字

//-------------------------------------
//	ここがエンジン部本体ね♪
//-------------------------------------
int Text_engine();


//end of file




